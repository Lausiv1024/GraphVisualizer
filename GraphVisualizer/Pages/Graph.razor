@page "/graph"
@using GraphLibrary
@inject IJSRuntime JSRuntime
<div class="base">
    <div class="controller lritem">

        
        <button @onclick="click"></button>
        <div >
            <div class="nodes list-group">
                @foreach (var node in Nodes)
                {
                    if (SelectedNode == node)
                    {
                        <button type="button" class="list-group-item list-group-item-action active">@(node.id + ":" + node.title)</button>

                    }
                    else
                    {
                        <button type="button" @onclick="()=>SelectNode(node)" class="list-group-item list-group-item-action">@(node.id + ":" + node.title)</button>

                    }
                }

            </div>
        </div>


        <button>nodeの追加</button>

        <div class="edges list-group">

            @if(SelectedNode != null){
                foreach (var edge in SelectedNode.ToEdges)
                {
                    if(SelectedToEdge == edge)
                    {
                        <button type="button" class="list-group-item list-group-item-action active">@($"({SelectedNode.id}:{SelectedNode.title}) - ({edge.ToNode.id}:{edge.ToNode.title})")</button>

                    }
                    else
                    {
                        <button type="button" @onclick="()=>SelectToEdge(edge)" class="list-group-item list-group-item-action">@($"({SelectedNode.id}:{SelectedNode.title}) - ({edge.ToNode.id}:{edge.ToNode.title})")</button>

                    }
                }
            }
        </div>
        <button>edgeを追加</button>

    </div>
    <div id="cy" class="center-item"></div>
    <div class="lritem">
    </div>
</div>


<style>
    .base{
        display:flex;
        justify-items:stretch;
        justify-content: space-between;
        height:100vh;
    }

    .controller{
        background-color:red;
        padding:10px;
    }

    .center-item {
        flex-grow: 1;
    }

    .lritem {
        width: 150px;
    }

    .edge{
        height:400px;
    }
    .nodes{
        height:200px;
        max-height:200px;
        overflow: auto;
        overflow-y: scroll;
    }
</style>
@code {
    List<Node> Nodes = new List<Node>();
    ToEdge SelectedToEdge;
    Node SelectedNode;
    void SelectToEdge(ToEdge toEdge)
    {
        SelectedToEdge = toEdge;
    }
    void SelectNode(Node node)
    {
        if (node == SelectedNode)
        {
            return;
        }
        SelectedNode = node;
        SelectedToEdge = null;

    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Node.ColorChange = NodeColorChange;
            Node.CreateNode = CreateNode;
            Node.DeleteNode = DeleteNode;
            ToEdge.ColorChange = EdgeColorChange;
            ToEdge.DeleteChange = EdgeDelete;
            ToEdge.WeightChange = WeightChange;
            ToEdge.ToNodeChange = ToNodeChange;


            var node0 =  Node.Create("0", "gray", "0");
            var node1 = Node.Create("1", "gray", "1");
            var node2 = Node.Create("2", "gray", "2");
            var node3 = Node.Create("3", "gray", "3");
            var node4 = Node.Create("4", "gray", "4");
            var node5 = Node.Create("5", "gray", "5");
            var node6 = Node.Create("6", "gray", "6");
            var node7 = Node.Create("7", "gray", "7");
            node0.NewToEdge(node1,-1);
            node0.NewToEdge(node2,-1);
            node2.NewToEdge(node3,-1);
            node3.NewToEdge(node0, -1);
            node3.NewToEdge(node4, -1);
            node4.NewToEdge(node5, -1);
            node3.NewToEdge(node6, -1);
            node6.NewToEdge(node1, -1);
            EdgeAndNode en = new EdgeAndNode();
            en.Nodes = Node.Nodes.Select(x => new InNodeObject { data = x.ToInternalNode() }).ToList();
            en.Edges = Node.Edges.Select(x => new InEdgeObject { data = x.ToInternalEdge() }).ToList();
            await JSRuntime.InvokeVoidAsync("drawGraph", "cy",en);

            StateHasChanged();
        }

    }
    bool tmp = false;
    async Task click()
    {
        // await JSRuntime.InvokeVoidAsync("changeNodeColor", "a", "black");
        // await JSRuntime.InvokeVoidAsync("changeEdgeColor", "ab", "orange");
        // await JSRuntime.InvokeVoidAsync("changeEdgeSource", "ab", "t12");
        // await JSRuntime.InvokeVoidAsync("drawGraph", "cy");

        //await JSRuntime.InvokeVoidAsync("isDirected", tmp);
        var node =  Node.Create("a", "blue", "abc");
        node.NewToEdge(node,10);
        var edges = node.ToEdges;
        var d = edges.First().ToInternalEdge();

        d.source = "t12";
        d.color = "blue";
        d.id = "ab";
        await JSRuntime.InvokeVoidAsync("updateNode", d);
        tmp = !tmp;
    }

    void EdgeColorChange(Edge toEdge)
    {
        
    }
    void WeightChange(Edge edge)
    {

    }
    void EdgeDelete(Edge edge)
    {

    }
    void EdgeWeightChange(Edge edge)
    {

    }
    void ToNodeChange(Edge edge)
    {

    }

    void NodeColorChange(Node node)
    {

    }

    void CreateNode(Node node)
    {
        Nodes = Node.Nodes.ToList();
        if (!Nodes.Contains(SelectedNode))
        {
            SelectedNode = null;
        }
        StateHasChanged();
    }
    void DeleteNode(Node node)
    {
        Nodes = Node.Nodes.ToList();
        if (!Nodes.Contains(SelectedNode))
        {
            SelectedNode = null;
        }
        StateHasChanged();
    }
}
